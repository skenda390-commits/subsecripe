<!doctype html>
<html lang="ar">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>مسجل المشهد (Three.js + CCapture)</title>
    <!-- Three.js (unpkg) -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
    <!-- CCapture.js (cdnjs) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ccapture.js/1.1.0/CCapture.min.js"></script>
    <style>
      :root {
        --bg: #0b1020;
        --panel: #0f1724;
        --accent: #06b6d4;
        --muted: #9aa6b2;
        --white: #ffffff;
        --radius: 12px;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: Inter, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      }
      body {
        background: linear-gradient(180deg, #071428 0%, #081325 100%);
        color: var(--white);
        display: flex;
        align-items: stretch;
        gap: 16px;
        padding: 20px;
        box-sizing: border-box;
      }

      /* Left: canvas area */
      .canvas-wrap {
        flex: 1 1 0;
        min-width: 320px;
        border-radius: var(--radius);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        position: relative;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
        border-radius: 8px;
        background: #000;
      }

      /* Right: controls */
      .sidebar {
        width: 360px;
        max-width: 40%;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
        border-radius: var(--radius);
        padding: 16px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      h1 {
        font-size: 18px;
        margin: 0 0 6px 0;
      }
      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }

      select,
      input[type="number"],
      button {
        width: 100%;
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.06);
        background: transparent;
        color: var(--white);
        box-sizing: border-box;
      }

      .bottom-menu.media {
        display: flex;
        justify-content: space-between;
        
        gap: 8px;
        align-items: center;
      }
      .bottom-menu.media select {
        flex: 1;
      }
      .bottom-menu.media .w-20 {
        width: 80px;
      }
      .flex-row {
        display: flex;
        align-items: center;
      }
      .gap-2 {
        gap: 8px;
      }

      .btn {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        justify-content: center;
        background: linear-gradient(90deg, var(--accent), #7dd3fc);
        color: #002;
        border: none;
        padding: 8px 12px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
      }
      .btn:active {
        transform: translateY(1px);
      }
      .icon-btn {
        width: 44px;
        height: 44px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.03);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(255, 255, 255, 0.03);
        cursor: pointer;
      }

      #status-message {
        position: absolute;
        right: 16px;
        top: 16px;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.06);
        padding: 8px 12px;
        border-radius: 10px;
        display: none;
      }

      /* Modal */
      .modal-container {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.6);
        z-index: 40;
      }
      .modal-content {
        background: var(--panel);
        padding: 20px;
        border-radius: 12px;
        max-width: 90%;
        width: 800px;
        position: relative;
      }
      #video-player {
        width: 100%;
        height: 480px;
        background: #000;
        border-radius: 8px;
        display: block;
      }

      /* small helpers */
      .muted {
        color: var(--muted);
        font-size: 13px;
      }
      .subscriber-only {
        opacity: 0.4;
      }
      .hidden {
        display: none;
      }
      @media (max-width: 900px) {
        body {
          flex-direction: column;
        }
        .sidebar {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="canvas-wrap">
      <div id="status-message"></div>
      <!-- Three.js canvas will be appended here by script -->
      <div id="renderer-container" style="flex: 1; min-height: 360px; border-radius: 8px; overflow: hidden"></div>
      <div class="muted">المشهد: مكعب ثلاثي الأبعاد يدور (Three.js) — يتم تسجيل محتوى الـ canvas</div>
    </div>

    <div class="sidebar">
      <h1>قائمة تسجيل MediaRecorder / CCapture</h1>

      <label for="export-format">الصيغة:</label>
      <select id="export-format">
        <option value="png">PNG (صورة)</option>
        <option value="jpg">JPG (صورة)</option>
        <option value="webm">WEBM (فيديو)</option>
        <option value="mp4" class="subscriber-only">MP4 (يفترض دعم المتصفح؛ قد يُحفظ كـ WEBM)</option>
      </select>

      <label for="export-dimensions">الأبعاد (px):</label>
      <select id="export-dimensions">
        <option value="1920x1080">1920x1080 (HD)</option>
        <option value="1280x720">1280x720 (HD)</option>
        <option value="1080x1920">1080x1920</option>
        <option value="1080x1080">1080x1080</option>
        <option value="1080x1350">1080x1350</option>
        <option value="1080x566">1080x566</option>
        <option value="1200x630">1200x630</option>
        <option value="1600x900">1600x900</option>
        <option value="1200x627">1200x627</option>
        <option value="1280x720">1280x720</option>
      </select>

      <div id="video-duration-container" class="flex-row items-center gap-2">
        <label for="video-duration" class="text-sm text-white">المدة (ثواني):</label>
        <input type="number" id="video-duration" value="5" min="1" class="w-20" />
      </div>

      <div class="bottom-menu media" style="margin-top: 6px">
        <button id="capture-button" class="icon-btn" title="التقاط / تسجيل">
          <!-- camera icon -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="20px"
            viewBox="0 -960 960 960"
            width="20px"
            fill="currentColor">
            <path
              d="M480-320 280-520l56-58 104 104v-326h80v326l104-104 56 58-200 200ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z" />
          </svg>
        </button>

        <button id="stop-button" class="icon-btn hidden" title="إيقاف التسجيل (يدوياً)">
          <!-- stop icon -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="20px"
            viewBox="0 -960 960 960"
            width="20px"
            fill="currentColor">
            <path d="M240-200h480v-560H240v560z" />
          </svg>
        </button>

        <button id="play-button" style="display: none" class="icon-btn" title="تشغيل المعاينة">
          <!-- play -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="20px"
            viewBox="0 -960 960 960"
            width="20px"
            fill="currentColor">
            <path d="M320-200v-560l440 280-440 280Z" />
          </svg>
        </button>

        <button id="download-last" class="btn" style="display: none">تحميل الملف</button>
      </div>

      
    </div>

    <!-- فيديو المعاينة مودال -->
    <div id="video-player-modal" class="modal-container">
      <div class="modal-content">
        <button
          id="video-close"
          class="absolute top-4 right-4"
          style="
            position: absolute;
            right: 12px;
            top: 8px;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 28px;
            line-height: 1;
            cursor: pointer;
          ">
          &times;
        </button>
        <h2 style="margin: 0 0 12px 0">تشغيل الفيديو المسجل</h2>
        <video id="video-player" controls autoplay></video>
      </div>
    </div>

    <script>
      /*
  Implementation notes:
  - Three.js creates a simple rotating cube on a WebGL canvas.
  - For images (PNG/JPG): we resize renderer to chosen dimension, render one frame, then export canvas.toDataURL and download.
  - For video (WEBM): we use CCapture.js to record frames from the animation loop at a chosen framerate.
    CCapture will assemble a WebM blob and make it available to download.
  - MP4: client-side MP4 recording is not widely supported. We attempt MediaRecorder with 'video/mp4' if available,
    otherwise we fallback to recording a webm using MediaRecorder and save with .webm extension.
  - We support manual stop as well as auto-stop after specified duration.
*/

      let scene, camera, renderer, cube, clock;
      let animId;
      let capturing = false;
      let capturer = null;
      let recordedBlob = null; // last recorded blob
      let lastFilename = "";
      const rendererContainer = document.getElementById("renderer-container");

      // create three.js scene
      function initThree(width = 800, height = 600) {
        // clear existing renderer if any
        if (renderer) {
          cancelAnimationFrame(animId);
          renderer.dispose();
          rendererContainer.innerHTML = "";
        }

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x081020);

        camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
        camera.position.set(2, 2, 3);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true }); // preserveDrawingBuffer for toDataURL
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio ? Math.min(window.devicePixelRatio, 2) : 1);
        rendererContainer.appendChild(renderer.domElement);

        // lazy resize style so canvas fits container
        renderer.domElement.style.width = "100%";
        renderer.domElement.style.height = "100%";

        // cube
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({ color: 0x44aaff, metalness: 0.3, roughness: 0.5 });
        cube = new THREE.Mesh(geometry, material);
        scene.add(cube);

        // lights
        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(5, 5, 5);
        scene.add(dir);
        scene.add(new THREE.AmbientLight(0xffffff, 0.3));

        clock = new THREE.Clock();
      }

      // animation loop (we will incorporate CCapture frame capture inside it when active)
      function animate() {
        const delta = clock.getDelta();
        cube.rotation.x += delta * 0.8;
        cube.rotation.y += delta * 0.6;

        renderer.render(scene, camera);

        // if capturer active, capture a frame (works for CCapture)
        if (capturing && capturer && capturer.capture) {
          try {
            capturer.capture(renderer.domElement);
          } catch (err) {
            console.warn("capturer.capture failed:", err);
          }
        }

        animId = requestAnimationFrame(animate);
      }

      // --- Utility functions ---
      function showStatus(msg, timeout = 3000) {
        const el = document.getElementById("status-message");
        el.style.display = "block";
        el.textContent = msg;
        if (timeout) {
          setTimeout(() => {
            if (el.textContent === msg) el.style.display = "none";
          }, timeout);
        }
      }

      function parseDimensions(value) {
        const [w, h] = value.split("x").map((v) => parseInt(v, 10));
        return { w, h };
      }

      function dataURLtoBlob(dataurl) {
        const arr = dataurl.split(","),
          mime = arr[0].match(/:(.*?);/)[1],
          bstr = atob(arr[1]),
          n = bstr.length,
          u8arr = new Uint8Array(n);
        for (let i = 0; i < n; i++) u8arr[i] = bstr.charCodeAt(i);
        return new Blob([u8arr], { type: mime });
      }

      // download helper
      function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 10000);
      }

      // --- Recording logic ---
      const formatSelect = document.getElementById("export-format");
      const dimsSelect = document.getElementById("export-dimensions");
      const durationInput = document.getElementById("video-duration");
      const captureBtn = document.getElementById("capture-button");
      const playBtn = document.getElementById("play-button");
      const stopBtn = document.getElementById("stop-button");
      const downloadBtn = document.getElementById("download-last");
      const videoModal = document.getElementById("video-player-modal");
      const videoPlayer = document.getElementById("video-player");
      const videoClose = document.getElementById("video-close");

      function enablePlayPreview(enable) {
        playBtn.style.display = enable ? "inline-flex" : "none";
        downloadBtn.style.display = enable ? "inline-flex" : "none";
      }

      function prepareRendererSizeForExport(dimVal) {
        const { w, h } = parseDimensions(dimVal);
        // set renderer size (also updates canvas)
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }

      // capture single frame (PNG/JPG)
      async function captureImage(format, dims) {
        prepareRendererSizeForExport(dims);
        // render one frame
        renderer.render(scene, camera);
        // get dataURL
        const mime = format === "jpg" ? "image/jpeg" : "image/png";
        const dataURL = renderer.domElement.toDataURL(mime, 0.92);
        const blob = dataURLtoBlob(dataURL);
        const filename = `capture_${Date.now()}.${format === "jpg" ? "jpg" : "png"}`;
        downloadBlob(blob, filename);
        recordedBlob = blob;
        lastFilename = filename;
        enablePlayPreview(false); // image can't "play"
        showStatus("تم التقاط الصورة وحفظها.");
      }

      // record video using CCapture (frames -> WebM)
      function startCCaptureRecording(options) {
        // options: {format: 'webm', framerate: number}
        // configure CCapture
        const opts = {
          format: options.format || "webm",
          framerate: options.framerate || 60,
          verbose: true,
          quality: 100
          // name: 'capture'
        };

        // When format is webm, CCapture will produce a webm blob (in newer versions).
        capturer = new CCapture(opts);
        try {
          capturer.start();
          capturing = true;
          showStatus("بدء التسجيل باستخدام CCapture...");
        } catch (err) {
          console.error("CCapture start failed", err);
          showStatus("فشل بدء CCapture — محاولة استخدام MediaRecorder كاحتياط...");
          capturer = null;
          capturing = false;
        }
      }

      // stop CCapture and obtain blob (CCapture provides a save method that triggers download).
      // Since CCapture historically forced download, we will attempt to capture result via onStop callback if available.
      // Fallback: call capturer.save() which triggers download.
      function stopCCaptureRecordingAndSave(filename) {
        if (!capturer) {
          showStatus("لا يوجد capturer فعال.");
          return;
        }
        // CCapture stop - this will finalize the recording; in many builds it triggers immediate download via capturer.save()
        try {
          capturer.stop();
          // try to get the result if CCapture exposes it
          if (typeof capturer.save === "function") {
            // If save triggers download, it will run; but we also try to intercept the resulting blob by overriding document.createElement('a')? that's hacky.
            // Simpler: call save() and let the browser download automatically.
            capturer.save();
            showStatus("تم إيقاف التسجيل. بدأ تنزيل WebM (إذا دعم المتصفح ذلك).");
          } else {
            showStatus("تم إيقاف التسجيل. يرجى التحقق من التنزيل الذي بدأ.");
          }
        } catch (err) {
          console.error("Error stopping capturer", err);
          showStatus("حدث خطأ أثناء إيقاف CCapture.");
        } finally {
          capturing = false;
          capturer = null;
        }
      }

      // Alternative: record canvas stream via MediaRecorder (works reliably for webm; mp4 only if browser supports)
      function recordViaMediaRecorder(durationSec, targetMime) {
        return new Promise(async (resolve, reject) => {
          const stream = renderer.domElement.captureStream(60); // request 60fps
          let options = {};
          if (targetMime) options.mimeType = targetMime;
          let mediaRecorder;
          let chunks = [];
          try {
            mediaRecorder = new MediaRecorder(stream, options);
          } catch (err) {
            // fallback to default
            try {
              mediaRecorder = new MediaRecorder(stream);
            } catch (err2) {
              return reject(err2);
            }
          }
          mediaRecorder.ondataavailable = (e) => {
            if (e.data && e.data.size) chunks.push(e.data);
          };
          mediaRecorder.onerror = (e) => {
            console.error("MediaRecorder error", e);
          };
          mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: chunks[0]?.type || "video/webm" });
            recordedBlob = blob;
            resolve(blob);
          };
          mediaRecorder.start();
          showStatus("بدء التسجيل عبر MediaRecorder...");
          // stop after duration unless stopped manually
          setTimeout(() => {
            if (mediaRecorder.state !== "inactive") mediaRecorder.stop();
          }, durationSec * 1000);
        });
      }

      // main start capture handler
      async function startCaptureAction() {
        if (!renderer) {
          initThree(1280, 720);
          animate();
        }

        const format = formatSelect.value;
        const dims = dimsSelect.value;
        const durationSec = Math.max(1, parseInt(durationInput.value || "5", 10));

        // if image (png/jpg): capture immediate single frame
        if (format === "png" || format === "jpg") {
          // temporarily set renderer size to target dims, capture image, then restore to container size
          const { w, h } = parseDimensions(dims);
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          // render & capture
          await captureImage(format, dims);
          // restore to container size for display (responsive)
          // set to container client size
          const cw = rendererContainer.clientWidth;
          const ch = Math.max(300, rendererContainer.clientHeight);
          renderer.setSize(cw, ch, false);
          camera.aspect = cw / ch;
          camera.updateProjectionMatrix();
          return;
        }

        // if video:
        // Try using CCapture for 'webm' (frame-accurate). For mp4 or if CCapture unavailable, fallback to MediaRecorder.
        if (format === "webm") {
          // set renderer size to dims
          const { w, h } = parseDimensions(dims);
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();

          // start CCapture
          startCCaptureRecording({ format: "webm", framerate: 60 });
          // ensure animation loop running
          if (!animId) animate();

          // UI changes
          captureBtn.style.opacity = "0.5";
          captureBtn.disabled = true;
          stopBtn.classList.remove("hidden");

          // auto-stop after duration
          setTimeout(() => {
            // stop capturer and save
            stopBtn.classList.add("hidden");
            captureBtn.disabled = false;
            captureBtn.style.opacity = "1";
            stopCCaptureRecordingAndSave(`capture_${Date.now()}.webm`);
            // restore canvas size to container
            const cw = rendererContainer.clientWidth;
            const ch = Math.max(360, rendererContainer.clientHeight);
            renderer.setSize(cw, ch, false);
            camera.aspect = cw / ch;
            camera.updateProjectionMatrix();
          }, durationSec * 1000);

          return;
        }

        if (format === "mp4") {
          // Attempt MediaRecorder with mp4 mime (rarely supported). If not, fallback to webm.
          const { w, h } = parseDimensions(dims);
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();

          let mime = "video/mp4";
          let blob = null;
          try {
            blob = await recordViaMediaRecorder(durationSec, mime);
          } catch (err) {
            console.warn("mp4 MediaRecorder failed, fallback to webm", err);
            try {
              blob = await recordViaMediaRecorder(durationSec, "video/webm;codecs=vp9");
            } catch (err2) {
              console.error("Fallback MediaRecorder failed", err2);
              showStatus("تعذر تسجيل الفيديو في هذا المتصفح.");
              return;
            }
          }
          // download blob
          const ext = blob.type.includes("mp4") ? "mp4" : "webm";
          lastFilename = `capture_${Date.now()}.${ext}`;
          downloadBlob(blob, lastFilename);
          enablePlayPreview(true);
          showStatus("انتهى التسجيل. يمكنك المعاينة أو التحميل.");
          return;
        }

        // fallback other video formats -> webm via MediaRecorder
        {
          const { w, h } = parseDimensions(dims);
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();

          let blob;
          try {
            blob = await recordViaMediaRecorder(durationSec, "video/webm;codecs=vp9");
          } catch (err) {
            // try without specifying mime
            try {
              blob = await recordViaMediaRecorder(durationSec, "");
            } catch (err2) {
              console.error("Recording failed", err2);
              showStatus("فشل التسجيل.");
              return;
            }
          }
          lastFilename = `capture_${Date.now()}.webm`;
          downloadBlob(blob, lastFilename);
          enablePlayPreview(true);
          showStatus("تم التسجيل وحفظ الملف.");
        }
      }

      // Stop button handler (for CCapture scenario manual stop)
      function stopManualCapture() {
        if (capturer) {
          stopCCaptureRecordingAndSave(`capture_${Date.now()}.webm`);
          capturing = false;
          capturer = null;
          stopBtn.classList.add("hidden");
          showStatus("توقف التسجيل يدويًا.");
          enablePlayPreview(true);
        } else {
          showStatus("لا عملية تسجيل حالية للتوقف.");
        }
      }

      // Play preview the last blob (if video)
      function openPreview() {
        if (!recordedBlob) {
          // If last action produced a downloaded blob but not saved in recordedBlob (e.g., CCapture.save triggered automatic download),
          // we may not have the blob in memory. In that case, notify user to download.
          showStatus("لا يوجد معاينة محلية. إذا تم تنزيل الملف تلقائياً، افتحه من جهازك.");
          // But try to open lastFilename if available? Not possible due to sandbox.
          return;
        }
        const url = URL.createObjectURL(recordedBlob);
        videoPlayer.src = url;
        videoModal.style.display = "flex";
      }

      // event wiring
      captureBtn.addEventListener("click", async (e) => {
        // If recording is currently in progress (capturing true and capturer exists), ignore or stop?
        if (capturing && capturer) {
          showStatus("التسجيل جارٍ بالفعل...");
          return;
        }
        // Ensure renderer exists
        if (!renderer) {
          // init with default dims
          const d = parseDimensions(dimsSelect.value);
          initThree(d.w, d.h);
          animate();
        }
        await startCaptureAction();
      });

      // stop manual
      stopBtn.addEventListener("click", stopManualCapture);

      // play preview
      playBtn.addEventListener("click", () => {
        // If recordedBlob not set, try to construct from last downloaded file? Not possible - show message.
        if (!recordedBlob) {
          // If last download was automatic via CCapture.save (and not accessible), we can't preview it.
          showStatus("لا يوجد ملف فيديو في الذاكرة للمعاينة. بعض التنسيقات تُحمَّل تلقائياً بواسطة المتصفح.");
          return;
        }
        openPreview();
      });

      // close modal
      videoClose.addEventListener("click", () => {
        videoModal.style.display = "none";
        videoPlayer.pause();
        if (videoPlayer.src) {
          URL.revokeObjectURL(videoPlayer.src);
          videoPlayer.src = "";
        }
      });

      // download button for last recorded blob (if available)
      downloadBtn.addEventListener("click", () => {
        if (!recordedBlob) {
          showStatus("لا يوجد ملف متاح للتحميل محليًا.");
          return;
        }
        const fname = lastFilename || `capture_${Date.now()}.webm`;
        downloadBlob(recordedBlob, fname);
        showStatus("بدأ تحميل الملف.");
      });

      // When format is image, hide duration input
      formatSelect.addEventListener("change", () => {
        const fmt = formatSelect.value;
        const durContainer = document.getElementById("video-duration-container");
        if (fmt === "png" || fmt === "jpg") {
          durContainer.style.display = "none";
        } else {
          durContainer.style.display = "flex";
        }
      });

      // Initialize small default renderer to fit container
      function initOnLoad() {
        // default dims = container client size
        const cw = rendererContainer.clientWidth || 800;
        const ch = Math.max(360, rendererContainer.clientHeight || 480);
        initThree(cw, ch);
        animate();
        // ensure UI initial state
        formatSelect.dispatchEvent(new Event("change"));
        enablePlayPreview(false);
        showStatus("جاهز — يمكنك التسجيل أو التقاط صورة.", 2500);
      }

      // on resize, adjust renderer to container (only when not recording)
      window.addEventListener("resize", () => {
        if (!renderer) return;
        if (capturing) return; // don't change size mid-capture
        const cw = rendererContainer.clientWidth;
        const ch = Math.max(360, rendererContainer.clientHeight);
        renderer.setSize(cw, ch, false);
        camera.aspect = cw / ch;
        camera.updateProjectionMatrix();
      });

      initOnLoad();

      /* Notes for future improvements:
 - For deterministic high-quality video, CCapture + an offscreen canvas with fixed framerate is ideal.
 - CCapture.save() often triggers direct download; hooking into its internal blob may need a custom build.
 - MP4 creation client-side reliably requires ffmpeg.wasm (heavy) or server-side encoding.
 - This sample focuses on practicality and compatibility across modern browsers.
*/
    </script>
  </body>
</html>
