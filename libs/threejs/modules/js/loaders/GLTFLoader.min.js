! function() {
    function e() {
        let e = {};
        return {
            get: function(t) {
                return e[t]
            },
            add: function(t, s) {
                e[t] = s
            },
            remove: function(t) {
                delete e[t]
            },
            removeAll: function() {
                e = {}
            }
        }
    }
    const t = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
    };
    class s {
        constructor(e) {
            this.parser = e, this.name = t.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
            }
        }
        _markDefs() {
            const e = this.parser,
                t = this.parser.json.nodes || [];
            for (let s = 0, n = t.length; s < n; s++) {
                const n = t[s];
                n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && e._addNodeRef(this.cache, n.extensions[this.name].light)
            }
        }
        _loadLight(e) {
            const t = this.parser,
                s = "light:" + e;
            let n = t.cache.get(s);
            if (n) return n;
            const r = t.json,
                o = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
            let a;
            const i = new THREE.Color(16777215);
            void 0 !== o.color && i.fromArray(o.color);
            const l = void 0 !== o.range ? o.range : 0;
            switch (o.type) {
                case "directional":
                    (a = new THREE.DirectionalLight(i)).target.position.set(0, 0, -1), a.add(a.target);
                    break;
                case "point":
                    (a = new THREE.PointLight(i)).distance = l;
                    break;
                case "spot":
                    (a = new THREE.SpotLight(i)).distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, a.angle = o.spot.outerConeAngle, a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
            }
            return a.position.set(0, 0, 0), a.decay = 2, void 0 !== o.intensity && (a.intensity = o.intensity), a.name = t.createUniqueName(o.name || "light_" + e), n = Promise.resolve(a), t.cache.add(s, n), n
        }
        createNodeAttachment(e) {
            const t = this,
                s = this.parser,
                n = s.json.nodes[e],
                r = (n.extensions && n.extensions[this.name] || {}).light;
            return void 0 === r ? null : this._loadLight(r).then(function(e) {
                return s._getNodeRef(t.cache, r, e)
            })
        }
    }
    class n {
        constructor() {
            this.name = t.KHR_MATERIALS_UNLIT
        }
        getMaterialType() {
            return THREE.MeshBasicMaterial
        }
        extendParams(e, t, s) {
            const n = [];
            e.color = new THREE.Color(1, 1, 1), e.opacity = 1;
            const r = t.pbrMetallicRoughness;
            if (r) {
                if (Array.isArray(r.baseColorFactor)) {
                    const t = r.baseColorFactor;
                    e.color.fromArray(t), e.opacity = t[3]
                }
                void 0 !== r.baseColorTexture && n.push(s.assignTexture(e, "map", r.baseColorTexture))
            }
            return Promise.all(n)
        }
    }
    class r {
        constructor(e) {
            this.parser = e, this.name = t.KHR_MATERIALS_CLEARCOAT
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? THREE.MeshPhysicalMaterial : null
        }
        extendMaterialParams(e, t) {
            const s = this.parser,
                n = s.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const r = [],
                o = n.extensions[this.name];
            if (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && r.push(s.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && r.push(s.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (r.push(s.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
                const e = o.clearcoatNormalTexture.scale;
                t.clearcoatNormalScale = new THREE.Vector2(e, -e)
            }
            return Promise.all(r)
        }
    }
    class o {
        constructor(e) {
            this.parser = e, this.name = t.KHR_MATERIALS_TRANSMISSION
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? THREE.MeshPhysicalMaterial : null
        }
        extendMaterialParams(e, t) {
            const s = this.parser,
                n = s.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const r = [],
                o = n.extensions[this.name];
            return void 0 !== o.transmissionFactor && (t.transmission = o.transmissionFactor), void 0 !== o.transmissionTexture && r.push(s.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(r)
        }
    }
    class a {
        constructor(e) {
            this.parser = e, this.name = t.KHR_TEXTURE_BASISU
        }
        loadTexture(e) {
            const t = this.parser,
                s = t.json,
                n = s.textures[e];
            if (!n.extensions || !n.extensions[this.name]) return null;
            const r = n.extensions[this.name],
                o = s.images[r.source],
                a = t.options.ktx2Loader;
            if (!a) {
                if (s.extensionsRequired && s.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null
            }
            return t.loadTextureImage(e, o, a)
        }
    }
    class i {
        constructor(e) {
            this.parser = e, this.name = t.EXT_TEXTURE_WEBP, this.isSupported = null
        }
        loadTexture(e) {
            const t = this.name,
                s = this.parser,
                n = s.json,
                r = n.textures[e];
            if (!r.extensions || !r.extensions[t]) return null;
            const o = r.extensions[t],
                a = n.images[o.source];
            let i = s.textureLoader;
            if (a.uri) {
                const e = s.options.manager.getHandler(a.uri);
                null !== e && (i = e)
            }
            return this.detectSupport().then(function(r) {
                if (r) return s.loadTextureImage(e, a, i);
                if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return s.loadTexture(e)
            })
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise(function(e) {
                const t = new Image;
                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                    e(1 === t.height)
                }
            })), this.isSupported
        }
    }
    class l {
        constructor(e) {
            this.name = t.EXT_MESHOPT_COMPRESSION, this.parser = e
        }
        loadBufferView(e) {
            const t = this.parser.json,
                s = t.bufferViews[e];
            if (s.extensions && s.extensions[this.name]) {
                const e = s.extensions[this.name],
                    n = this.parser.getDependency("buffer", e.buffer),
                    r = this.parser.options.meshoptDecoder;
                if (!r || !r.supported) {
                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null
                }
                return Promise.all([n, r.ready]).then(function(t) {
                    const s = e.byteOffset || 0,
                        n = e.byteLength || 0,
                        o = e.count,
                        a = e.byteStride,
                        i = new ArrayBuffer(o * a),
                        l = new Uint8Array(t[0], s, n);
                    return r.decodeGltfBuffer(new Uint8Array(i), o, a, l, e.mode, e.filter), i
                })
            }
            return null
        }
    }
    const c = "glTF",
        u = 12,
        h = {
            JSON: 1313821514,
            BIN: 5130562
        };
    class p {
        constructor(e) {
            this.name = t.KHR_BINARY_GLTF, this.content = null, this.body = null;
            const s = new DataView(e, 0, u);
            if (this.header = {
                    magic: THREE.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
                    version: s.getUint32(4, !0),
                    length: s.getUint32(8, !0)
                }, this.header.magic !== c) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const n = this.header.length - u,
                r = new DataView(e, u);
            let o = 0;
            for (; o < n;) {
                const t = r.getUint32(o, !0);
                o += 4;
                const s = r.getUint32(o, !0);
                if (o += 4, s === h.JSON) {
                    const s = new Uint8Array(e, u + o, t);
                    this.content = THREE.LoaderUtils.decodeText(s)
                } else if (s === h.BIN) {
                    const s = u + o;
                    this.body = e.slice(s, s + t)
                }
                o += t
            }
            if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
        }
    }
    class d {
        constructor(e, s) {
            if (!s) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = t.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = s, this.dracoLoader.preload()
        }
        decodePrimitive(e, t) {
            const s = this.json,
                n = this.dracoLoader,
                r = e.extensions[this.name].bufferView,
                o = e.extensions[this.name].attributes,
                a = {},
                i = {},
                l = {};
            for (const e in o) {
                const t = A[e] || e.toLowerCase();
                a[t] = o[e]
            }
            for (const t in e.attributes) {
                const n = A[t] || t.toLowerCase();
                if (void 0 !== o[t]) {
                    const r = s.accessors[e.attributes[t]],
                        o = x[r.componentType];
                    l[n] = o, i[n] = !0 === r.normalized
                }
            }
            return t.getDependency("bufferView", r).then(function(e) {
                return new Promise(function(t) {
                    n.decodeDracoFile(e, function(e) {
                        for (const t in e.attributes) {
                            const s = e.attributes[t],
                                n = i[t];
                            void 0 !== n && (s.normalized = n)
                        }
                        t(e)
                    }, a, l)
                })
            })
        }
    }
    class m {
        constructor() {
            this.name = t.KHR_TEXTURE_TRANSFORM
        }
        extendTexture(e, t) {
            return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale ? e : (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e)
        }
    }
    class f extends THREE.MeshStandardMaterial {
        constructor(e) {
            super(), this.isGLTFSpecularGlossinessMaterial = !0;
            const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                s = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                n = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                a = {
                    specular: {
                        value: (new THREE.Color).setHex(16777215)
                    },
                    glossiness: {
                        value: 1
                    },
                    specularMap: {
                        value: null
                    },
                    glossinessMap: {
                        value: null
                    }
                };
            this._extraUniforms = a, this.onBeforeCompile = function(e) {
                for (const t in a) e.uniforms[t] = a[t];
                e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", s).replace("#include <roughnessmap_fragment>", n).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", o)
            }, Object.defineProperties(this, {
                specular: {
                    get: function() {
                        return a.specular.value
                    },
                    set: function(e) {
                        a.specular.value = e
                    }
                },
                specularMap: {
                    get: function() {
                        return a.specularMap.value
                    },
                    set: function(e) {
                        a.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                    }
                },
                glossiness: {
                    get: function() {
                        return a.glossiness.value
                    },
                    set: function(e) {
                        a.glossiness.value = e
                    }
                },
                glossinessMap: {
                    get: function() {
                        return a.glossinessMap.value
                    },
                    set: function(e) {
                        a.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                    }
                }
            }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
        }
    }
    class E {
        constructor() {
            this.name = t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
        }
        getMaterialType() {
            return f
        }
        extendParams(e, t, s) {
            const n = t.extensions[this.name];
            e.color = new THREE.Color(1, 1, 1), e.opacity = 1;
            const r = [];
            if (Array.isArray(n.diffuseFactor)) {
                const t = n.diffuseFactor;
                e.color.fromArray(t), e.opacity = t[3]
            }
            if (void 0 !== n.diffuseTexture && r.push(s.assignTexture(e, "map", n.diffuseTexture)), e.emissive = new THREE.Color(0, 0, 0), e.glossiness = void 0 !== n.glossinessFactor ? n.glossinessFactor : 1, e.specular = new THREE.Color(1, 1, 1), Array.isArray(n.specularFactor) && e.specular.fromArray(n.specularFactor), void 0 !== n.specularGlossinessTexture) {
                const t = n.specularGlossinessTexture;
                r.push(s.assignTexture(e, "glossinessMap", t)), r.push(s.assignTexture(e, "specularMap", t))
            }
            return Promise.all(r)
        }
        createMaterial(e) {
            const t = new f(e);
            return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = THREE.TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t
        }
    }
    class g {
        constructor() {
            this.name = t.KHR_MESH_QUANTIZATION
        }
    }
    class T extends THREE.Interpolant {
        constructor(e, t, s, n) {
            super(e, t, s, n)
        }
        copySampleValue_(e) {
            const t = this.resultBuffer,
                s = this.sampleValues,
                n = this.valueSize,
                r = e * n * 3 + n;
            for (let e = 0; e !== n; e++) t[e] = s[r + e];
            return t
        }
    }
    T.prototype.beforeStart_ = T.prototype.copySampleValue_, T.prototype.afterEnd_ = T.prototype.copySampleValue_, T.prototype.interpolate_ = function(e, t, s, n) {
        const r = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            i = 2 * a,
            l = 3 * a,
            c = n - t,
            u = (s - t) / c,
            h = u * u,
            p = h * u,
            d = e * l,
            m = d - l,
            f = -2 * p + 3 * h,
            E = p - h,
            g = 1 - f,
            T = E - h + u;
        for (let e = 0; e !== a; e++) {
            const t = o[m + e + a],
                s = o[m + e + i] * c,
                n = o[d + e + a],
                l = o[d + e] * c;
            r[e] = g * t + T * s + f * n + E * l
        }
        return r
    };
    const R = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
        },
        x = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        },
        M = {
            9728: THREE.NearestFilter,
            9729: THREE.LinearFilter,
            9984: THREE.NearestMipmapNearestFilter,
            9985: THREE.LinearMipmapNearestFilter,
            9986: THREE.NearestMipmapLinearFilter,
            9987: THREE.LinearMipmapLinearFilter
        },
        v = {
            33071: THREE.ClampToEdgeWrapping,
            33648: THREE.MirroredRepeatWrapping,
            10497: THREE.RepeatWrapping
        },
        S = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        },
        A = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        },
        L = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        },
        y = {
            CUBICSPLINE: void 0,
            LINEAR: THREE.InterpolateLinear,
            STEP: THREE.InterpolateDiscrete
        },
        _ = {
            OPAQUE: "OPAQUE",
            MASK: "MASK",
            BLEND: "BLEND"
        };

    function H(e, t) {
        return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) ? e : /^data:.*,.*$/i.test(e) ? e : /^blob:.*$/i.test(e) ? e : t + e)
    }

    function w(e, t, s) {
        for (const n in s.extensions) void 0 === e[n] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[n] = s.extensions[n])
    }

    function b(e, t) {
        void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
    }

    function I(e, t) {
        if (e.updateMorphTargets(), void 0 !== t.weights)
            for (let s = 0, n = t.weights.length; s < n; s++) e.morphTargetInfluences[s] = t.weights[s];
        if (t.extras && Array.isArray(t.extras.targetNames)) {
            const s = t.extras.targetNames;
            if (e.morphTargetInfluences.length === s.length) {
                e.morphTargetDictionary = {};
                for (let t = 0, n = s.length; t < n; t++) e.morphTargetDictionary[s[t]] = t
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
        }
    }

    function N(e) {
        const s = e.extensions && e.extensions[t.KHR_DRACO_MESH_COMPRESSION];
        let n;
        return n = s ? "draco:" + s.bufferView + ":" + s.indices + ":" + P(s.attributes) : e.indices + ":" + P(e.attributes) + ":" + e.mode
    }

    function P(e) {
        let t = "";
        const s = Object.keys(e).sort();
        for (let n = 0, r = s.length; n < r; n++) t += s[n] + ":" + e[s[n]] + ";";
        return t
    }

    function O(e) {
        switch (e) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
        }
    }
    class C {
        constructor(t = {}, s = {}) {
            this.json = t, this.extensions = {}, this.plugins = {}, this.options = s, this.cache = new e, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new THREE.ImageBitmapLoader(this.options.manager) : this.textureLoader = new THREE.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new THREE.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
        }
        setExtensions(e) {
            this.extensions = e
        }
        setPlugins(e) {
            this.plugins = e
        }
        parse(e, t) {
            const s = this,
                n = this.json,
                r = this.extensions;
            this.cache.removeAll(), this._invokeAll(function(e) {
                return e._markDefs && e._markDefs()
            }), Promise.all(this._invokeAll(function(e) {
                return e.beforeRoot && e.beforeRoot()
            })).then(function() {
                return Promise.all([s.getDependencies("scene"), s.getDependencies("animation"), s.getDependencies("camera")])
            }).then(function(t) {
                const o = {
                    scene: t[0][n.scene || 0],
                    scenes: t[0],
                    animations: t[1],
                    cameras: t[2],
                    asset: n.asset,
                    parser: s,
                    userData: {}
                };
                w(r, o, n), b(o, n), Promise.all(s._invokeAll(function(e) {
                    return e.afterRoot && e.afterRoot(o)
                })).then(function() {
                    e(o)
                })
            }).catch(t)
        }
        _markDefs() {
            const e = this.json.nodes || [],
                t = this.json.skins || [],
                s = this.json.meshes || [];
            for (let s = 0, n = t.length; s < n; s++) {
                const n = t[s].joints;
                for (let t = 0, s = n.length; t < s; t++) e[n[t]].isBone = !0
            }
            for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t];
                void 0 !== n.mesh && (this._addNodeRef(this.meshCache, n.mesh), void 0 !== n.skin && (s[n.mesh].isSkinnedMesh = !0)), void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera)
            }
        }
        _addNodeRef(e, t) {
            void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
        }
        _getNodeRef(e, t, s) {
            if (e.refs[t] <= 1) return s;
            const n = s.clone();
            return n.name += "_instance_" + e.uses[t]++, n
        }
        _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for (let s = 0; s < t.length; s++) {
                const n = e(t[s]);
                if (n) return n
            }
            return null
        }
        _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const s = [];
            for (let n = 0; n < t.length; n++) {
                const r = e(t[n]);
                r && s.push(r)
            }
            return s
        }
        getDependency(e, t) {
            const s = e + ":" + t;
            let n = this.cache.get(s);
            if (!n) {
                switch (e) {
                    case "scene":
                        n = this.loadScene(t);
                        break;
                    case "node":
                        n = this.loadNode(t);
                        break;
                    case "mesh":
                        n = this._invokeOne(function(e) {
                            return e.loadMesh && e.loadMesh(t)
                        });
                        break;
                    case "accessor":
                        n = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        n = this._invokeOne(function(e) {
                            return e.loadBufferView && e.loadBufferView(t)
                        });
                        break;
                    case "buffer":
                        n = this.loadBuffer(t);
                        break;
                    case "material":
                        n = this._invokeOne(function(e) {
                            return e.loadMaterial && e.loadMaterial(t)
                        });
                        break;
                    case "texture":
                        n = this._invokeOne(function(e) {
                            return e.loadTexture && e.loadTexture(t)
                        });
                        break;
                    case "skin":
                        n = this.loadSkin(t);
                        break;
                    case "animation":
                        n = this.loadAnimation(t);
                        break;
                    case "camera":
                        n = this.loadCamera(t);
                        break;
                    default:
                        throw new Error("Unknown type: " + e)
                }
                this.cache.add(s, n)
            }
            return n
        }
        getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
                const s = this,
                    n = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                t = Promise.all(n.map(function(t, n) {
                    return s.getDependency(e, n)
                })), this.cache.add(e, t)
            }
            return t
        }
        loadBuffer(e) {
            const s = this.json.buffers[e],
                n = this.fileLoader;
            if (s.type && "arraybuffer" !== s.type) throw new Error("THREE.GLTFLoader: " + s.type + " buffer type is not supported.");
            if (void 0 === s.uri && 0 === e) return Promise.resolve(this.extensions[t.KHR_BINARY_GLTF].body);
            const r = this.options;
            return new Promise(function(e, t) {
                n.load(H(s.uri, r.path), e, void 0, function() {
                    t(new Error('THREE.GLTFLoader: Failed to load buffer "' + s.uri + '".'))
                })
            })
        }
        loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then(function(e) {
                const s = t.byteLength || 0,
                    n = t.byteOffset || 0;
                return e.slice(n, n + s)
            })
        }
        loadAccessor(e) {
            const t = this,
                s = this.json,
                n = this.json.accessors[e];
            if (void 0 === n.bufferView && void 0 === n.sparse) return Promise.resolve(null);
            const r = [];
            return void 0 !== n.bufferView ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null), void 0 !== n.sparse && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(r).then(function(e) {
                const r = e[0],
                    o = S[n.type],
                    a = x[n.componentType],
                    i = a.BYTES_PER_ELEMENT,
                    l = i * o,
                    c = n.byteOffset || 0,
                    u = void 0 !== n.bufferView ? s.bufferViews[n.bufferView].byteStride : void 0,
                    h = !0 === n.normalized;
                let p, d;
                if (u && u !== l) {
                    const e = Math.floor(c / u),
                        s = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + e + ":" + n.count;
                    let l = t.cache.get(s);
                    l || (p = new a(r, e * u, n.count * u / i), l = new THREE.InterleavedBuffer(p, u / i), t.cache.add(s, l)), d = new THREE.InterleavedBufferAttribute(l, o, c % u / i, h)
                } else p = null === r ? new a(n.count * o) : new a(r, c, n.count * o), d = new THREE.BufferAttribute(p, o, h);
                if (void 0 !== n.sparse) {
                    const t = S.SCALAR,
                        s = x[n.sparse.indices.componentType],
                        i = n.sparse.indices.byteOffset || 0,
                        l = n.sparse.values.byteOffset || 0,
                        c = new s(e[1], i, n.sparse.count * t),
                        u = new a(e[2], l, n.sparse.count * o);
                    null !== r && (d = new THREE.BufferAttribute(d.array.slice(), d.itemSize, d.normalized));
                    for (let e = 0, t = c.length; e < t; e++) {
                        const t = c[e];
                        if (d.setX(t, u[e * o]), o >= 2 && d.setY(t, u[e * o + 1]), o >= 3 && d.setZ(t, u[e * o + 2]), o >= 4 && d.setW(t, u[e * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.")
                    }
                }
                return d
            })
        }
        loadTexture(e) {
            const t = this.json,
                s = this.options,
                n = t.textures[e],
                r = t.images[n.source];
            let o = this.textureLoader;
            if (r.uri) {
                const e = s.manager.getHandler(r.uri);
                null !== e && (o = e)
            }
            return this.loadTextureImage(e, r, o)
        }
        loadTextureImage(e, t, s) {
            const n = this,
                r = this.json,
                o = this.options,
                a = r.textures[e],
                i = (t.uri || t.bufferView) + ":" + a.sampler;
            if (this.textureCache[i]) return this.textureCache[i];
            const l = self.URL || self.webkitURL;
            let c = t.uri || "",
                u = !1,
                h = !0;
            const p = c.search(/\.jpe?g($|\?)/i) > 0 || 0 === c.search(/^data\:image\/jpeg/);
            if (("image/jpeg" === t.mimeType || p) && (h = !1), void 0 !== t.bufferView) c = n.getDependency("bufferView", t.bufferView).then(function(e) {
                if ("image/png" === t.mimeType) {
                    const t = new DataView(e, 25, 1).getUint8(0, !1);
                    h = 6 === t || 4 === t || 3 === t
                }
                u = !0;
                const s = new Blob([e], {
                    type: t.mimeType
                });
                return c = l.createObjectURL(s)
            });
            else if (void 0 === t.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            const d = Promise.resolve(c).then(function(e) {
                return new Promise(function(t, n) {
                    let r = t;
                    !0 === s.isImageBitmapLoader && (r = function(e) {
                        const s = new THREE.Texture(e);
                        s.needsUpdate = !0, t(s)
                    }), s.load(H(e, o.path), r, void 0, n)
                })
            }).then(function(t) {
                !0 === u && l.revokeObjectURL(c), t.flipY = !1, a.name && (t.name = a.name), h || (t.format = THREE.RGBFormat);
                const s = (r.samplers || {})[a.sampler] || {};
                return t.magFilter = M[s.magFilter] || THREE.LinearFilter, t.minFilter = M[s.minFilter] || THREE.LinearMipmapLinearFilter, t.wrapS = v[s.wrapS] || THREE.RepeatWrapping, t.wrapT = v[s.wrapT] || THREE.RepeatWrapping, n.associations.set(t, {
                    type: "textures",
                    index: e
                }), t
            }).catch(function() {
                return console.error("THREE.GLTFLoader: Couldn't load texture", c), null
            });
            return this.textureCache[i] = d, d
        }
        assignTexture(e, s, n) {
            const r = this;
            return this.getDependency("texture", n.index).then(function(o) {
                if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === s && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + s + " not yet supported."), r.extensions[t.KHR_TEXTURE_TRANSFORM]) {
                    const e = void 0 !== n.extensions ? n.extensions[t.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (e) {
                        const s = r.associations.get(o);
                        o = r.extensions[t.KHR_TEXTURE_TRANSFORM].extendTexture(o, e), r.associations.set(o, s)
                    }
                }
                e[s] = o
            })
        }
        assignFinalMaterial(e) {
            const t = e.geometry;
            let s = e.material;
            const n = void 0 !== t.attributes.tangent,
                r = void 0 !== t.attributes.color,
                o = void 0 === t.attributes.normal,
                a = Object.keys(t.morphAttributes).length > 0,
                i = a && void 0 !== t.morphAttributes.normal;
            if (e.isPoints) {
                const e = "PointsMaterial:" + s.uuid;
                let t = this.cache.get(e);
                t || (t = new THREE.PointsMaterial, THREE.Material.prototype.copy.call(t, s), t.color.copy(s.color), t.map = s.map, t.sizeAttenuation = !1, this.cache.add(e, t)), s = t
            } else if (e.isLine) {
                const e = "LineBasicMaterial:" + s.uuid;
                let t = this.cache.get(e);
                t || (t = new THREE.LineBasicMaterial, THREE.Material.prototype.copy.call(t, s), t.color.copy(s.color), this.cache.add(e, t)), s = t
            }
            if (n || r || o || a) {
                let e = "ClonedMaterial:" + s.uuid + ":";
                s.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), n && (e += "vertex-tangents:"), r && (e += "vertex-colors:"), o && (e += "flat-shading:"), a && (e += "morph-targets:"), i && (e += "morph-normals:");
                let t = this.cache.get(e);
                t || (t = s.clone(), r && (t.vertexColors = !0), o && (t.flatShading = !0), a && (t.morphTargets = !0), i && (t.morphNormals = !0), n && (t.vertexTangents = !0, t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(s))), s = t
            }
            s.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = s
        }
        getMaterialType() {
            return THREE.MeshStandardMaterial
        }
        loadMaterial(e) {
            const s = this,
                n = this.json,
                r = this.extensions,
                o = n.materials[e];
            let a;
            const i = {},
                l = o.extensions || {},
                c = [];
            if (l[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                const e = r[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                a = e.getMaterialType(), c.push(e.extendParams(i, o, s))
            } else if (l[t.KHR_MATERIALS_UNLIT]) {
                const e = r[t.KHR_MATERIALS_UNLIT];
                a = e.getMaterialType(), c.push(e.extendParams(i, o, s))
            } else {
                const t = o.pbrMetallicRoughness || {};
                if (i.color = new THREE.Color(1, 1, 1), i.opacity = 1, Array.isArray(t.baseColorFactor)) {
                    const e = t.baseColorFactor;
                    i.color.fromArray(e), i.opacity = e[3]
                }
                void 0 !== t.baseColorTexture && c.push(s.assignTexture(i, "map", t.baseColorTexture)), i.metalness = void 0 !== t.metallicFactor ? t.metallicFactor : 1, i.roughness = void 0 !== t.roughnessFactor ? t.roughnessFactor : 1, void 0 !== t.metallicRoughnessTexture && (c.push(s.assignTexture(i, "metalnessMap", t.metallicRoughnessTexture)), c.push(s.assignTexture(i, "roughnessMap", t.metallicRoughnessTexture))), a = this._invokeOne(function(t) {
                    return t.getMaterialType && t.getMaterialType(e)
                }), c.push(Promise.all(this._invokeAll(function(t) {
                    return t.extendMaterialParams && t.extendMaterialParams(e, i)
                })))
            }!0 === o.doubleSided && (i.side = THREE.DoubleSide);
            const u = o.alphaMode || _.OPAQUE;
            return u === _.BLEND ? (i.transparent = !0, i.depthWrite = !1) : (i.transparent = !1, u === _.MASK && (i.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : .5)), void 0 !== o.normalTexture && a !== THREE.MeshBasicMaterial && (c.push(s.assignTexture(i, "normalMap", o.normalTexture)), i.normalScale = new THREE.Vector2(1, -1), void 0 !== o.normalTexture.scale && i.normalScale.set(o.normalTexture.scale, -o.normalTexture.scale)), void 0 !== o.occlusionTexture && a !== THREE.MeshBasicMaterial && (c.push(s.assignTexture(i, "aoMap", o.occlusionTexture)), void 0 !== o.occlusionTexture.strength && (i.aoMapIntensity = o.occlusionTexture.strength)), void 0 !== o.emissiveFactor && a !== THREE.MeshBasicMaterial && (i.emissive = (new THREE.Color).fromArray(o.emissiveFactor)), void 0 !== o.emissiveTexture && a !== THREE.MeshBasicMaterial && c.push(s.assignTexture(i, "emissiveMap", o.emissiveTexture)), Promise.all(c).then(function() {
                let n;
                return n = a === f ? r[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(i) : new a(i), o.name && (n.name = o.name), n.map && (n.map.encoding = THREE.sRGBEncoding), n.emissiveMap && (n.emissiveMap.encoding = THREE.sRGBEncoding), b(n, o), s.associations.set(n, {
                    type: "materials",
                    index: e
                }), o.extensions && w(r, n, o), n
            })
        }
        createUniqueName(e) {
            const t = THREE.PropertyBinding.sanitizeNodeName(e || "");
            let s = t;
            for (let e = 1; this.nodeNamesUsed[s]; ++e) s = t + "_" + e;
            return this.nodeNamesUsed[s] = !0, s
        }
        loadGeometries(e) {
            const s = this,
                n = this.extensions,
                r = this.primitiveCache;

            function o(e) {
                return n[t.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, s).then(function(t) {
                    return U(t, e, s)
                })
            }
            const a = [];
            for (let n = 0, i = e.length; n < i; n++) {
                const i = e[n],
                    l = N(i),
                    c = r[l];
                if (c) a.push(c.promise);
                else {
                    let e;
                    e = i.extensions && i.extensions[t.KHR_DRACO_MESH_COMPRESSION] ? o(i) : U(new THREE.BufferGeometry, i, s), r[l] = {
                        primitive: i,
                        promise: e
                    }, a.push(e)
                }
            }
            return Promise.all(a)
        }
        loadMesh(e) {
            const t = this,
                s = this.json,
                n = this.extensions,
                r = s.meshes[e],
                o = r.primitives,
                a = [];
            for (let e = 0, t = o.length; e < t; e++) {
                const t = void 0 === o[e].material ? (void 0 === (i = this.cache).DefaultMaterial && (i.DefaultMaterial = new THREE.MeshStandardMaterial({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: THREE.FrontSide
                })), i.DefaultMaterial) : this.getDependency("material", o[e].material);
                a.push(t)
            }
            var i;
            return a.push(t.loadGeometries(o)), Promise.all(a).then(function(s) {
                const a = s.slice(0, s.length - 1),
                    i = s[s.length - 1],
                    l = [];
                for (let s = 0, c = i.length; s < c; s++) {
                    const c = i[s],
                        u = o[s];
                    let h;
                    const p = a[s];
                    if (u.mode === R.TRIANGLES || u.mode === R.TRIANGLE_STRIP || u.mode === R.TRIANGLE_FAN || void 0 === u.mode) !0 !== (h = !0 === r.isSkinnedMesh ? new THREE.SkinnedMesh(c, p) : new THREE.Mesh(c, p)).isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), u.mode === R.TRIANGLE_STRIP ? h.geometry = D(h.geometry, THREE.TriangleStripDrawMode) : u.mode === R.TRIANGLE_FAN && (h.geometry = D(h.geometry, THREE.TriangleFanDrawMode));
                    else if (u.mode === R.LINES) h = new THREE.LineSegments(c, p);
                    else if (u.mode === R.LINE_STRIP) h = new THREE.Line(c, p);
                    else if (u.mode === R.LINE_LOOP) h = new THREE.LineLoop(c, p);
                    else {
                        if (u.mode !== R.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
                        h = new THREE.Points(c, p)
                    }
                    Object.keys(h.geometry.morphAttributes).length > 0 && I(h, r), h.name = t.createUniqueName(r.name || "mesh_" + e), b(h, r), u.extensions && w(n, h, u), t.assignFinalMaterial(h), l.push(h)
                }
                if (1 === l.length) return l[0];
                const c = new THREE.Group;
                for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
                return c
            })
        }
        loadCamera(e) {
            let t;
            const s = this.json.cameras[e],
                n = s[s.type];
            if (n) return "perspective" === s.type ? t = new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : "orthographic" === s.type && (t = new THREE.OrthographicCamera(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), s.name && (t.name = this.createUniqueName(s.name)), b(t, s), Promise.resolve(t);
            console.warn("THREE.GLTFLoader: Missing camera parameters.")
        }
        loadSkin(e) {
            const t = this.json.skins[e],
                s = {
                    joints: t.joints
                };
            return void 0 === t.inverseBindMatrices ? Promise.resolve(s) : this.getDependency("accessor", t.inverseBindMatrices).then(function(e) {
                return s.inverseBindMatrices = e, s
            })
        }
        loadAnimation(e) {
            const t = this.json.animations[e],
                s = [],
                n = [],
                r = [],
                o = [],
                a = [];
            for (let e = 0, i = t.channels.length; e < i; e++) {
                const i = t.channels[e],
                    l = t.samplers[i.sampler],
                    c = i.target,
                    u = void 0 !== c.node ? c.node : c.id,
                    h = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
                    p = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
                s.push(this.getDependency("node", u)), n.push(this.getDependency("accessor", h)), r.push(this.getDependency("accessor", p)), o.push(l), a.push(c)
            }
            return Promise.all([Promise.all(s), Promise.all(n), Promise.all(r), Promise.all(o), Promise.all(a)]).then(function(s) {
                const n = s[0],
                    r = s[1],
                    o = s[2],
                    a = s[3],
                    i = s[4],
                    l = [];
                for (let e = 0, t = n.length; e < t; e++) {
                    const t = n[e],
                        s = r[e],
                        c = o[e],
                        u = a[e],
                        h = i[e];
                    if (void 0 === t) continue;
                    let p;
                    switch (t.updateMatrix(), t.matrixAutoUpdate = !0, L[h.path]) {
                        case L.weights:
                            p = THREE.NumberKeyframeTrack;
                            break;
                        case L.rotation:
                            p = THREE.QuaternionKeyframeTrack;
                            break;
                        case L.position:
                        case L.scale:
                        default:
                            p = THREE.VectorKeyframeTrack
                    }
                    const d = t.name ? t.name : t.uuid,
                        m = void 0 !== u.interpolation ? y[u.interpolation] : THREE.InterpolateLinear,
                        f = [];
                    L[h.path] === L.weights ? t.traverse(function(e) {
                        !0 === e.isMesh && e.morphTargetInfluences && f.push(e.name ? e.name : e.uuid)
                    }) : f.push(d);
                    let E = c.array;
                    if (c.normalized) {
                        const e = O(E.constructor),
                            t = new Float32Array(E.length);
                        for (let s = 0, n = E.length; s < n; s++) t[s] = E[s] * e;
                        E = t
                    }
                    for (let e = 0, t = f.length; e < t; e++) {
                        const t = new p(f[e] + "." + L[h.path], s.array, E, m);
                        "CUBICSPLINE" === u.interpolation && (t.createInterpolant = function(e) {
                            return new T(this.times, this.values, this.getValueSize() / 3, e)
                        }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(t)
                    }
                }
                const c = t.name ? t.name : "animation_" + e;
                return new THREE.AnimationClip(c, void 0, l)
            })
        }
        createNodeMesh(e) {
            const t = this.json,
                s = this,
                n = t.nodes[e];
            return void 0 === n.mesh ? null : s.getDependency("mesh", n.mesh).then(function(e) {
                const t = s._getNodeRef(s.meshCache, n.mesh, e);
                return void 0 !== n.weights && t.traverse(function(e) {
                    if (e.isMesh)
                        for (let t = 0, s = n.weights.length; t < s; t++) e.morphTargetInfluences[t] = n.weights[t]
                }), t
            })
        }
        loadNode(e) {
            const t = this.json,
                s = this.extensions,
                n = this,
                r = t.nodes[e],
                o = r.name ? n.createUniqueName(r.name) : "";
            return function() {
                const t = [],
                    s = n._invokeOne(function(t) {
                        return t.createNodeMesh && t.createNodeMesh(e)
                    });
                return s && t.push(s), void 0 !== r.camera && t.push(n.getDependency("camera", r.camera).then(function(e) {
                    return n._getNodeRef(n.cameraCache, r.camera, e)
                })), n._invokeAll(function(t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                }).forEach(function(e) {
                    t.push(e)
                }), Promise.all(t)
            }().then(function(t) {
                let a;
                if ((a = !0 === r.isBone ? new THREE.Bone : t.length > 1 ? new THREE.Group : 1 === t.length ? t[0] : new THREE.Object3D) !== t[0])
                    for (let e = 0, s = t.length; e < s; e++) a.add(t[e]);
                if (r.name && (a.userData.name = r.name, a.name = o), b(a, r), r.extensions && w(s, a, r), void 0 !== r.matrix) {
                    const e = new THREE.Matrix4;
                    e.fromArray(r.matrix), a.applyMatrix4(e)
                } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
                return n.associations.set(a, {
                    type: "nodes",
                    index: e
                }), a
            })
        }
        loadScene(e) {
            const t = this.json,
                s = this.extensions,
                n = this.json.scenes[e],
                r = this,
                o = new THREE.Group;
            n.name && (o.name = r.createUniqueName(n.name)), b(o, n), n.extensions && w(s, o, n);
            const a = n.nodes || [],
                i = [];
            for (let e = 0, s = a.length; e < s; e++) i.push(F(a[e], o, t, r));
            return Promise.all(i).then(function() {
                return o
            })
        }
    }

    function F(e, t, s, n) {
        const r = s.nodes[e];
        return n.getDependency("node", e).then(function(e) {
            if (void 0 === r.skin) return e;
            let t;
            return n.getDependency("skin", r.skin).then(function(e) {
                const s = [];
                for (let r = 0, o = (t = e).joints.length; r < o; r++) s.push(n.getDependency("node", t.joints[r]));
                return Promise.all(s)
            }).then(function(s) {
                return e.traverse(function(e) {
                    if (!e.isMesh) return;
                    const n = [],
                        r = [];
                    for (let e = 0, o = s.length; e < o; e++) {
                        const o = s[e];
                        if (o) {
                            n.push(o);
                            const s = new THREE.Matrix4;
                            void 0 !== t.inverseBindMatrices && s.fromArray(t.inverseBindMatrices.array, 16 * e), r.push(s)
                        } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                    }
                    e.bind(new THREE.Skeleton(n, r), e.matrixWorld)
                }), e
            })
        }).then(function(e) {
            t.add(e);
            const o = [];
            if (r.children) {
                const t = r.children;
                for (let r = 0, a = t.length; r < a; r++) {
                    const a = t[r];
                    o.push(F(a, e, s, n))
                }
            }
            return Promise.all(o)
        })
    }

    function U(e, t, s) {
        const n = t.attributes,
            r = [];

        function o(t, n) {
            return s.getDependency("accessor", t).then(function(t) {
                e.setAttribute(n, t)
            })
        }
        for (const t in n) {
            const s = A[t] || t.toLowerCase();
            s in e.attributes || r.push(o(n[t], s))
        }
        if (void 0 !== t.indices && !e.index) {
            const n = s.getDependency("accessor", t.indices).then(function(t) {
                e.setIndex(t)
            });
            r.push(n)
        }
        return b(e, t),
            function(e, t, s) {
                const n = t.attributes,
                    r = new THREE.Box3;
                if (void 0 === n.POSITION) return; {
                    const e = s.json.accessors[n.POSITION],
                        t = e.min,
                        o = e.max;
                    if (void 0 === t || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    if (r.set(new THREE.Vector3(t[0], t[1], t[2]), new THREE.Vector3(o[0], o[1], o[2])), e.normalized) {
                        const t = O(x[e.componentType]);
                        r.min.multiplyScalar(t), r.max.multiplyScalar(t)
                    }
                }
                const o = t.targets;
                if (void 0 !== o) {
                    const e = new THREE.Vector3,
                        t = new THREE.Vector3;
                    for (let n = 0, r = o.length; n < r; n++) {
                        const r = o[n];
                        if (void 0 !== r.POSITION) {
                            const n = s.json.accessors[r.POSITION],
                                o = n.min,
                                a = n.max;
                            if (void 0 !== o && void 0 !== a) {
                                if (t.setX(Math.max(Math.abs(o[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(o[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(o[2]), Math.abs(a[2]))), n.normalized) {
                                    const e = O(x[n.componentType]);
                                    t.multiplyScalar(e)
                                }
                                e.max(t)
                            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }
                    r.expandByVector(e)
                }
                e.boundingBox = r;
                const a = new THREE.Sphere;
                r.getCenter(a.center), a.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = a
            }(e, t, s), Promise.all(r).then(function() {
                return void 0 !== t.targets ? function(e, t, s) {
                    let n = !1,
                        r = !1;
                    for (let e = 0, s = t.length; e < s; e++) {
                        const s = t[e];
                        if (void 0 !== s.POSITION && (n = !0), void 0 !== s.NORMAL && (r = !0), n && r) break
                    }
                    if (!n && !r) return Promise.resolve(e);
                    const o = [],
                        a = [];
                    for (let i = 0, l = t.length; i < l; i++) {
                        const l = t[i];
                        if (n) {
                            const t = void 0 !== l.POSITION ? s.getDependency("accessor", l.POSITION) : e.attributes.position;
                            o.push(t)
                        }
                        if (r) {
                            const t = void 0 !== l.NORMAL ? s.getDependency("accessor", l.NORMAL) : e.attributes.normal;
                            a.push(t)
                        }
                    }
                    return Promise.all([Promise.all(o), Promise.all(a)]).then(function(t) {
                        const s = t[0],
                            o = t[1];
                        return n && (e.morphAttributes.position = s), r && (e.morphAttributes.normal = o), e.morphTargetsRelative = !0, e
                    })
                }(e, t.targets, s) : e
            })
    }

    function D(e, t) {
        let s = e.getIndex();
        if (null === s) {
            const t = [],
                n = e.getAttribute("position");
            if (void 0 === n) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
            for (let e = 0; e < n.count; e++) t.push(e);
            e.setIndex(t), s = e.getIndex()
        }
        const n = s.count - 2,
            r = [];
        if (t === THREE.TriangleFanDrawMode)
            for (let e = 1; e <= n; e++) r.push(s.getX(0)), r.push(s.getX(e)), r.push(s.getX(e + 1));
        else
            for (let e = 0; e < n; e++) e % 2 == 0 ? (r.push(s.getX(e)), r.push(s.getX(e + 1)), r.push(s.getX(e + 2))) : (r.push(s.getX(e + 2)), r.push(s.getX(e + 1)), r.push(s.getX(e)));
        r.length / 3 !== n && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const o = e.clone();
        return o.setIndex(r), o
    }
    THREE.GLTFLoader = class extends THREE.Loader {
        constructor(e) {
            super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e) {
                return new r(e)
            }), this.register(function(e) {
                return new a(e)
            }), this.register(function(e) {
                return new i(e)
            }), this.register(function(e) {
                return new o(e)
            }), this.register(function(e) {
                return new s(e)
            }), this.register(function(e) {
                return new l(e)
            })
        }
        load(e, t, s, n) {
            const r = this;
            let o;
            o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : THREE.LoaderUtils.extractUrlBase(e), this.manager.itemStart(e);
            const a = function(t) {
                    n ? n(t) : console.error(t), r.manager.itemError(e), r.manager.itemEnd(e)
                },
                i = new THREE.FileLoader(this.manager);
            i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(e, function(s) {
                try {
                    r.parse(s, o, function(s) {
                        t(s), r.manager.itemEnd(e)
                    }, a)
                } catch (e) {
                    a(e)
                }
            }, s, a)
        }
        setDRACOLoader(e) {
            return this.dracoLoader = e, this
        }
        setDDSLoader() {
            throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
        }
        setKTX2Loader(e) {
            return this.ktx2Loader = e, this
        }
        setMeshoptDecoder(e) {
            return this.meshoptDecoder = e, this
        }
        register(e) {
            return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
        }
        unregister(e) {
            return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
        }
        parse(e, s, r, o) {
            let a;
            const i = {},
                l = {};
            if ("string" == typeof e) a = e;
            else if (THREE.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === c) {
                try {
                    i[t.KHR_BINARY_GLTF] = new p(e)
                } catch (e) {
                    return void(o && o(e))
                }
                a = i[t.KHR_BINARY_GLTF].content
            } else a = THREE.LoaderUtils.decodeText(new Uint8Array(e));
            const u = JSON.parse(a);
            if (void 0 === u.asset || u.asset.version[0] < 2) return void(o && o(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
            const h = new C(u, {
                path: s || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            h.fileLoader.setRequestHeader(this.requestHeader);
            for (let e = 0; e < this.pluginCallbacks.length; e++) {
                const t = this.pluginCallbacks[e](h);
                l[t.name] = t, i[t.name] = !0
            }
            if (u.extensionsUsed)
                for (let e = 0; e < u.extensionsUsed.length; ++e) {
                    const s = u.extensionsUsed[e],
                        r = u.extensionsRequired || [];
                    switch (s) {
                        case t.KHR_MATERIALS_UNLIT:
                            i[s] = new n;
                            break;
                        case t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                            i[s] = new E;
                            break;
                        case t.KHR_DRACO_MESH_COMPRESSION:
                            i[s] = new d(u, this.dracoLoader);
                            break;
                        case t.KHR_TEXTURE_TRANSFORM:
                            i[s] = new m;
                            break;
                        case t.KHR_MESH_QUANTIZATION:
                            i[s] = new g;
                            break;
                        default:
                            r.indexOf(s) >= 0 && void 0 === l[s] && console.warn('THREE.GLTFLoader: Unknown extension "' + s + '".')
                    }
                }
            h.setExtensions(i), h.setPlugins(l), h.parse(r, o)
        }
    }
}();